{% extends "base.html" %}

{% block content %}
<div class="row">
    <div class="col-12">
        <h2>Live Analysis</h2>
        <p class="text-muted">Real-time workout analysis with your camera</p>
    </div>
</div>

<div class="row">
    <div class="col-md-8">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="mb-0">Camera Feed</h5>
                <span id="connection-status" class="badge bg-secondary">Disconnected</span>
            </div>
            <div class="card-body">
                <div id="camera-container" class="text-center position-relative">
                    <video id="video" width="640" height="480" autoplay style="border: 2px solid #ddd; border-radius: 8px;"></video>
                    <canvas id="canvas" width="640" height="480" style="display: none;"></canvas>
                    <canvas id="overlay-canvas" width="640" height="480" style="position: absolute; top: 0; left: 0; pointer-events: none; border-radius: 8px;"></canvas>
                </div>
                <div class="mt-3 text-center">
                    <div class="btn-group mb-2" role="group">
                        <button id="start-camera" class="btn btn-primary">Start Camera</button>
                        <button id="switch-camera" class="btn btn-outline-primary" title="Switch Camera" disabled>
                            <i class="fas fa-camera-rotate"></i>
                        </button>
                        <button id="stop-camera" class="btn btn-danger" disabled>Stop Camera</button>
                        <button id="end-workout" class="btn btn-warning" disabled>End Workout</button>
                    </div>
                    <div class="btn-group ms-2 mb-2" role="group">
                        <button id="rotate-left" class="btn btn-outline-secondary" title="Rotate Left 90°" disabled>
                            <i class="fas fa-undo"></i>
                        </button>
                        <button id="flip-horizontal" class="btn btn-outline-secondary" title="Flip Horizontal" disabled>
                            <i class="fas fa-arrows-alt-h"></i>
                        </button>
                        <button id="flip-vertical" class="btn btn-outline-secondary" title="Flip Vertical" disabled>
                            <i class="fas fa-arrows-alt-v"></i>
                        </button>
                        <button id="rotate-right" class="btn btn-outline-secondary" title="Rotate Right 90°" disabled>
                            <i class="fas fa-redo"></i>
                        </button>
                        <button id="reset-camera" class="btn btn-outline-info" title="Reset Camera" disabled>
                            <i class="fas fa-sync"></i>
                        </button>
                    </div>
                </div>
                <div class="mt-2 text-center">
                    <small id="camera-info" class="text-muted">Click Start Camera</small>
                </div>
            </div>
        </div>
    </div>

    <div class="col-md-4">
        <div class="card mb-3">
            <div class="card-header">
                <h5 class="mb-0">Exercise Selection</h5>
            </div>
            <div class="card-body">
                <select id="exercise-select" class="form-select mb-3">
                    <option value="">Select Exercise</option>
                    <option value="push_ups">Push-ups</option>
                    <option value="squats">Squats</option>
                    <option value="bicep_curls">Bicep Curls</option>
                </select>
                <button id="start-workout" class="btn btn-success w-100">Start Workout</button>
            </div>
        </div>

        <div class="card mb-3">
            <div class="card-header">
                <h5 class="mb-0">Live Stats</h5>
            </div>
            <div class="card-body">
                <div class="row text-center">
                    <div class="col-4">
                        <h3 id="rep-count" class="text-primary">0</h3>
                        <small>Reps</small>
                    </div>
                    <div class="col-4">
                        <h3 id="accuracy" class="text-success">0%</h3>
                        <small>Accuracy</small>
                    </div>
                    <div class="col-4">
                        <h3 id="phase" class="text-info">Ready</h3>
                        <small>Phase</small>
                    </div>
                </div>
                <div class="mt-2">
                    <small class="text-muted">Duration: <span id="duration">00:00</span></small>
                </div>
            </div>
        </div>

        <div class="card">
            <div class="card-header">
                <h5 class="mb-0">Live Feedback</h5>
            </div>
            <div class="card-body">
                <div id="feedback" class="alert alert-info">
                    Select an exercise and start your workout
                </div>
            </div>
        </div>

        <div class="card mt-3">
            <div class="card-header">
                <h5 class="mb-0">Camera Controls</h5>
            </div>
            <div class="card-body">
                <small class="text-muted">
                    <strong>Camera Selection:</strong><br>
                    • <i class="fas fa-camera-rotate"></i> Switch between available cameras<br>
                    <strong>Camera Rotation:</strong><br>
                    • <i class="fas fa-undo"></i> Rotate left 90°<br>
                    • <i class="fas fa-redo"></i> Rotate right 90°<br>
                    • <i class="fas fa-arrows-alt-h"></i> Flip horizontally<br>
                    • <i class="fas fa-arrows-alt-v"></i> Flip vertically<br>
                    • <i class="fas fa-sync"></i> Reset to default<br>
                    <em>Note: Controls are disabled during workout</em>
                </small>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
class SimpleWorkoutApp {
    constructor() {
        this.video = document.getElementById('video');
        this.canvas = document.getElementById('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.overlayCanvas = document.getElementById('overlay-canvas');
        this.overlayCtx = this.overlayCanvas.getContext('2d');
        this.websocket = null;
        this.sessionId = null;
        this.isWorkoutActive = false;
        this.currentStream = null;
        this.frameInterval = null;
        this.startTime = null;
        this.durationInterval = null;
        
        // Camera management
        this.availableCameras = [];
        this.currentCameraIndex = 0;
        
        // Camera transformation state
        this.cameraTransform = {
            rotation: 0,
            flipHorizontal: false,
            flipVertical: false
        };
        
        // MediaPipe visualization
        this.lastLandmarks = null;
        this.showSkeleton = true;
        
        this.initializeEventListeners();
        this.detectAvailableCameras();
        console.log('SimpleWorkoutApp initialized');
    }
    
    initializeEventListeners() {
        document.getElementById('start-camera').addEventListener('click', () => this.startCamera());
        document.getElementById('switch-camera').addEventListener('click', () => this.switchCamera());
        document.getElementById('stop-camera').addEventListener('click', () => this.stopCamera());
        document.getElementById('start-workout').addEventListener('click', () => this.startWorkout());
        document.getElementById('end-workout').addEventListener('click', () => this.endWorkout());
        
        // Camera transformation controls
        document.getElementById('rotate-left').addEventListener('click', () => this.rotateCamera(-90));
        document.getElementById('rotate-right').addEventListener('click', () => this.rotateCamera(90));
        document.getElementById('flip-horizontal').addEventListener('click', () => this.flipCamera('horizontal'));
        document.getElementById('flip-vertical').addEventListener('click', () => this.flipCamera('vertical'));
        document.getElementById('reset-camera').addEventListener('click', () => this.resetCamera());
    }
    
    async detectAvailableCameras() {
        try {
            console.log('Detecting available cameras...');
            
            if (this.isMobile()) {
                // For mobile, we know there are typically front and back cameras
                this.availableCameras = [
                    { deviceId: 'front', label: 'Front Camera', facingMode: 'user' },
                    { deviceId: 'back', label: 'Back Camera', facingMode: 'environment' }
                ];
                console.log('Mobile detected - using front/back camera setup');
            } else {
                // Default fallback for desktop
                this.availableCameras = [{ deviceId: 'default', label: 'Default Camera' }];
                
                // Try to get actual camera list for desktop
                if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
                    try {
                        const devices = await navigator.mediaDevices.enumerateDevices();
                        const videoDevices = devices.filter(device => device.kind === 'videoinput');
                        
                        if (videoDevices.length > 0) {
                            this.availableCameras = videoDevices;
                            console.log('Found desktop cameras:', videoDevices);
                        }
                    } catch (enumError) {
                        console.warn('Could not enumerate desktop devices:', enumError);
                    }
                }
            }
            
            this.updateCameraInfo();
            
        } catch (err) {
            console.error('Error detecting cameras:', err);
            this.availableCameras = [{ deviceId: 'default', label: 'Default Camera' }];
            this.updateCameraInfo();
        }
    }
    
    updateCameraInfo() {
        const cameraInfoElement = document.getElementById('camera-info');
        if (!cameraInfoElement) return;
        
        if (this.availableCameras.length === 0) {
            cameraInfoElement.textContent = 'No cameras available';
            return;
        }
        
        const currentCamera = this.availableCameras[this.currentCameraIndex];
        const cameraName = currentCamera.label || `Camera ${this.currentCameraIndex + 1}`;
        const cameraCount = this.availableCameras.length;
        
        cameraInfoElement.textContent = `${cameraName} (${this.currentCameraIndex + 1}/${cameraCount})`;
    }
    
    async startCamera() {
        try {
            console.log('Starting camera...');
            this.updateFeedback('Starting camera...', 'info');
            
            // Mobile-friendly camera constraints
            const constraints = {
                video: {
                    width: { ideal: 640, max: 1280 },
                    height: { ideal: 480, max: 720 },
                    facingMode: 'user' // Start with front camera on mobile
                }
            };
            
            // Use specific camera if available and not on mobile
            if (this.availableCameras.length > 0 && 
                this.availableCameras[this.currentCameraIndex].deviceId !== 'default' &&
                !this.isMobile()) {
                constraints.video.deviceId = { exact: this.availableCameras[this.currentCameraIndex].deviceId };
                delete constraints.video.facingMode;
            }
            
            console.log('Camera constraints:', constraints);
            
            this.currentStream = await navigator.mediaDevices.getUserMedia(constraints);
            this.video.srcObject = this.currentStream;
            
            // Wait for video to be ready
            await new Promise((resolve) => {
                this.video.onloadedmetadata = () => {
                    console.log('Video metadata loaded');
                    this.video.play().then(resolve).catch(resolve);
                };
            });
            
            document.getElementById('start-camera').disabled = true;
            document.getElementById('stop-camera').disabled = false;
            
            // Enable camera controls
            this.enableCameraControls(true);
            
            this.updateCameraInfo();
            this.updateFeedback('Camera started! Use controls to adjust orientation. Select an exercise and start workout.', 'success');
            console.log('Camera started successfully');
            
        } catch (err) {
            console.error('Camera error:', err);
            
            // Try fallback for mobile
            if (err.name === 'OverconstrainedError' || err.name === 'NotReadableError') {
                try {
                    console.log('Trying mobile fallback...');
                    this.currentStream = await navigator.mediaDevices.getUserMedia({ 
                        video: { facingMode: 'environment' } // Try back camera
                    });
                    this.video.srcObject = this.currentStream;
                    
                    document.getElementById('start-camera').disabled = true;
                    document.getElementById('stop-camera').disabled = false;
                    this.enableCameraControls(true);
                    
                    this.updateFeedback('Camera started with mobile fallback', 'success');
                    return;
                } catch (fallbackErr) {
                    console.error('Mobile fallback failed:', fallbackErr);
                }
            }
            
            let errorMsg = 'Camera access failed: ';
            
            if (err.name === 'NotAllowedError') {
                errorMsg += 'Permission denied. Please allow camera access and refresh the page.';
            } else if (err.name === 'NotFoundError') {
                errorMsg += 'No camera found.';
            } else if (err.name === 'NotSecureError') {
                errorMsg += 'Camera requires HTTPS. Please use ngrok or enable permissions for localhost.';
            } else {
                errorMsg += err.message;
            }
            
            this.updateFeedback(errorMsg, 'danger');
        }
    }
    
    isMobile() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }
    
    stopCamera() {
        if (this.currentStream) {
            this.currentStream.getTracks().forEach(track => track.stop());
            this.video.srcObject = null;
            this.currentStream = null;
        }
        
        document.getElementById('start-camera').disabled = false;
        document.getElementById('stop-camera').disabled = true;
        
        // Disable camera controls
        this.enableCameraControls(false);
        
        document.getElementById('camera-info').textContent = 'Camera stopped';
        this.updateFeedback('Camera stopped.', 'info');
        console.log('Camera stopped');
    }
    
    async switchCamera() {
        try {
            console.log('Switching camera...');
            
            // Stop current stream
            if (this.currentStream) {
                this.currentStream.getTracks().forEach(track => track.stop());
            }
            
            // Switch to next camera
            this.currentCameraIndex = (this.currentCameraIndex + 1) % this.availableCameras.length;
            const currentCamera = this.availableCameras[this.currentCameraIndex];
            
            let constraints;
            
            if (this.isMobile() && currentCamera.facingMode) {
                // Mobile camera switching
                constraints = {
                    video: {
                        facingMode: currentCamera.facingMode,
                        width: { ideal: 640, max: 1280 },
                        height: { ideal: 480, max: 720 }
                    }
                };
                console.log('Mobile camera constraints:', constraints);
            } else if (currentCamera.deviceId !== 'default') {
                // Desktop camera switching
                constraints = {
                    video: {
                        deviceId: { exact: currentCamera.deviceId },
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }
                };
            } else {
                // Fallback
                constraints = { video: true };
            }
            
            this.currentStream = await navigator.mediaDevices.getUserMedia(constraints);
            this.video.srcObject = this.currentStream;
            
            // Wait for video to load
            await new Promise((resolve) => {
                this.video.onloadedmetadata = () => {
                    this.video.play().then(resolve).catch(resolve);
                };
            });
            
            this.updateCameraInfo();
            this.updateFeedback(`Switched to: ${currentCamera.label}`, 'info');
            
        } catch (err) {
            console.error('Error switching camera:', err);
            this.updateFeedback('Error switching camera: ' + err.message, 'danger');
            
            // Try to restart the previous camera
            this.currentCameraIndex = (this.currentCameraIndex - 1 + this.availableCameras.length) % this.availableCameras.length;
            setTimeout(() => this.startCamera(), 1000);
        }
    }
    
    enableCameraControls(enabled) {
        const controls = ['switch-camera', 'rotate-left', 'rotate-right', 'flip-horizontal', 'flip-vertical', 'reset-camera'];
        controls.forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.disabled = !enabled;
            }
        });
        
        // Special handling for switch camera - only enable if multiple cameras available
        const switchBtn = document.getElementById('switch-camera');
        if (switchBtn && enabled && this.availableCameras.length <= 1) {
            switchBtn.disabled = true;
        }
    }
    
    rotateCamera(degrees) {
        this.cameraTransform.rotation = (this.cameraTransform.rotation + degrees) % 360;
        if (this.cameraTransform.rotation < 0) {
            this.cameraTransform.rotation += 360;
        }
        this.applyCameraTransform();
        this.updateFeedback(`Camera rotated ${degrees > 0 ? 'right' : 'left'} 90°`, 'info');
    }
    
    flipCamera(direction) {
        if (direction === 'horizontal') {
            this.cameraTransform.flipHorizontal = !this.cameraTransform.flipHorizontal;
            this.updateFeedback(`Camera ${this.cameraTransform.flipHorizontal ? 'flipped' : 'unflipped'} horizontally`, 'info');
        } else if (direction === 'vertical') {
            this.cameraTransform.flipVertical = !this.cameraTransform.flipVertical;
            this.updateFeedback(`Camera ${this.cameraTransform.flipVertical ? 'flipped' : 'unflipped'} vertically`, 'info');
        }
        this.applyCameraTransform();
    }
    
    resetCamera() {
        this.cameraTransform = {
            rotation: 0,
            flipHorizontal: false,
            flipVertical: false
        };
        this.applyCameraTransform();
        this.updateFeedback('Camera orientation reset to default', 'info');
    }
    
    applyCameraTransform() {
        let transform = `rotate(${this.cameraTransform.rotation}deg)`;
        
        if (this.cameraTransform.flipHorizontal) {
            transform += ' scaleX(-1)';
        }
        
        if (this.cameraTransform.flipVertical) {
            transform += ' scaleY(-1)';
        }
        
        this.video.style.transform = transform;
        this.video.style.transition = 'transform 0.3s ease';
    }
    
    async startWorkout() {
        const exercise = document.getElementById('exercise-select').value;
        
        if (!exercise) {
            alert('Please select an exercise first');
            return;
        }
        
        try {
            console.log('Starting workout:', exercise);
            this.updateFeedback('Starting workout...', 'info');
            
            // Create session
            const response = await fetch('/live/start-session', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    exercise_name: exercise,
                    user_id: 'demo_user'
                })
            });
            
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Server error: ${response.status} - ${errorText}`);
            }
            
            const data = await response.json();
            this.sessionId = data.session_id;
            console.log('Session created:', this.sessionId);
            
            // Connect WebSocket
            await this.connectWebSocket();
            
            // Start workout
            this.isWorkoutActive = true;
            this.startTime = Date.now();
            this.startDurationTimer();
            
            // Start frame capture if camera is available
            if (this.currentStream) {
                this.startFrameCapture();
            }
            
            // Update UI
            document.getElementById('start-workout').disabled = true;
            document.getElementById('end-workout').disabled = false;
            document.getElementById('exercise-select').disabled = true;
            
            // Disable camera controls during workout
            this.enableCameraControls(false);
            
            this.updateFeedback(`Workout started! Exercise: ${exercise.replace('_', ' ')}`, 'success');
            
        } catch (error) {
            console.error('Workout start error:', error);
            this.updateFeedback('Failed to start workout: ' + error.message, 'danger');
        }
    }
    
    async connectWebSocket() {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.host}/live/ws/${this.sessionId}`;
        
        console.log('Connecting WebSocket:', wsUrl);
        
        return new Promise((resolve, reject) => {
            this.websocket = new WebSocket(wsUrl);
            
            this.websocket.onopen = () => {
                console.log('WebSocket connected');
                document.getElementById('connection-status').textContent = 'Connected';
                document.getElementById('connection-status').className = 'badge bg-success';
                resolve();
            };
            
            this.websocket.onmessage = (event) => {
                const message = JSON.parse(event.data);
                this.handleWebSocketMessage(message);
            };
            
            this.websocket.onclose = () => {
                console.log('WebSocket closed');
                document.getElementById('connection-status').textContent = 'Disconnected';
                document.getElementById('connection-status').className = 'badge bg-danger';
            };
            
            this.websocket.onerror = (error) => {
                console.error('WebSocket error:', error);
                reject(error);
            };
            
            setTimeout(() => {
                if (this.websocket.readyState !== WebSocket.OPEN) {
                    reject(new Error('WebSocket timeout'));
                }
            }, 5000);
        });
    }
    
    handleWebSocketMessage(message) {
        console.log('WebSocket message:', message);
        
        switch (message.type) {
            case 'connected':
                this.updateFeedback(message.data.message, 'success');
                break;
            case 'analysis_result':
                this.updateStats(message.data);
                // Draw skeleton if landmarks are available
                if (message.data.landmarks) {
                    this.drawSkeleton(message.data.landmarks);
                }
                break;
            case 'rep_update':
                this.updateRepCount(message.data.rep_count, message.data.current_phase);
                break;
            case 'error':
                this.updateFeedback('Error: ' + message.data.message, 'danger');
                break;
        }
    }
    
    startFrameCapture() {
        this.frameInterval = setInterval(() => {
            if (this.isWorkoutActive && this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                this.captureAndSendFrame();
            }
        }, 200); // 5 FPS
    }
    
    captureAndSendFrame() {
        // Save current canvas context state
        this.ctx.save();
        
        // Clear canvas
        this.ctx.clearRect(0, 0, 640, 480);
        
        // Apply transformations to canvas context for frame processing
        this.ctx.translate(320, 240); // Move to center
        
        // Apply rotation
        this.ctx.rotate(this.cameraTransform.rotation * Math.PI / 180);
        
        // Apply flips
        let scaleX = this.cameraTransform.flipHorizontal ? -1 : 1;
        let scaleY = this.cameraTransform.flipVertical ? -1 : 1;
        this.ctx.scale(scaleX, scaleY);
        
        // Draw video frame with transformations
        this.ctx.drawImage(this.video, -320, -240, 640, 480);
        
        // Restore canvas context
        this.ctx.restore();
        
        const imageData = this.canvas.toDataURL('image/jpeg', 0.7);
        
        this.websocket.send(JSON.stringify({
            type: 'frame',
            data: {
                image: imageData,
                timestamp: Date.now(),
                transform: this.cameraTransform
            }
        }));
    }
    
    updateStats(data) {
        document.getElementById('rep-count').textContent = data.rep_count;
        document.getElementById('accuracy').textContent = Math.round(data.accuracy_score * 100) + '%';
        document.getElementById('phase').textContent = data.current_phase;
    }
    
    updateRepCount(repCount, phase) {
        document.getElementById('rep-count').textContent = repCount;
        document.getElementById('phase').textContent = phase;
    }
    
    startDurationTimer() {
        this.durationInterval = setInterval(() => {
            if (this.startTime) {
                const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                document.getElementById('duration').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }, 1000);
    }
    
    async endWorkout() {
        this.isWorkoutActive = false;
        
        if (this.frameInterval) {
            clearInterval(this.frameInterval);
            this.frameInterval = null;
        }
        
        if (this.durationInterval) {
            clearInterval(this.durationInterval);
            this.durationInterval = null;
        }
        
        if (this.websocket) {
            this.websocket.send(JSON.stringify({ type: 'end_session', data: {} }));
            this.websocket.close();
        }
        
        document.getElementById('start-workout').disabled = false;
        document.getElementById('end-workout').disabled = true;
        document.getElementById('exercise-select').disabled = false;
        
        // Re-enable camera controls
        if (this.currentStream) {
            this.enableCameraControls(true);
        }
        
        this.updateFeedback('Workout ended!', 'info');
    }
    
    updateFeedback(message, type) {
        const feedbackDiv = document.getElementById('feedback');
        feedbackDiv.textContent = message;
        feedbackDiv.className = `alert alert-${type}`;
        console.log(`Feedback: ${message}`);
    }
    
    drawSkeleton(landmarks) {
        if (!this.showSkeleton || !landmarks) return;
        
        // Clear overlay canvas
        this.overlayCtx.clearRect(0, 0, 640, 480);
        
        // Set drawing style for better visibility
        this.overlayCtx.strokeStyle = '#00ff00';
        this.overlayCtx.fillStyle = '#ff0000';
        this.overlayCtx.lineWidth = 3;
        this.overlayCtx.shadowColor = 'rgba(0, 0, 0, 0.5)';
        this.overlayCtx.shadowBlur = 2;
        
        // Draw skeleton connections first (behind landmarks)
        this.drawSkeletonConnections(landmarks);
        
        // Draw landmarks as points (on top)
        Object.entries(landmarks).forEach(([name, landmark]) => {
            if (landmark.visibility > 0.6) {
                const x = landmark.x * 640;
                const y = landmark.y * 480;
                
                // Draw larger, more visible points
                this.overlayCtx.beginPath();
                this.overlayCtx.arc(x, y, 6, 0, 2 * Math.PI);
                this.overlayCtx.fill();
                
                // Add white border for better visibility
                this.overlayCtx.strokeStyle = '#ffffff';
                this.overlayCtx.lineWidth = 2;
                this.overlayCtx.stroke();
                this.overlayCtx.strokeStyle = '#00ff00';
                this.overlayCtx.lineWidth = 3;
            }
        });
        
        this.lastLandmarks = landmarks;
    }
    
    drawSkeletonConnections(landmarks) {
        // Define pose connections with better visibility
        const connections = [
            // Face
            ['nose', 'left_eye'], ['nose', 'right_eye'],
            
            // Arms
            ['left_shoulder', 'right_shoulder'],
            ['left_shoulder', 'left_elbow'], ['left_elbow', 'left_wrist'],
            ['right_shoulder', 'right_elbow'], ['right_elbow', 'right_wrist'],
            
            // Body
            ['left_shoulder', 'left_hip'], ['right_shoulder', 'right_hip'],
            ['left_hip', 'right_hip'],
            
            // Legs
            ['left_hip', 'left_knee'], ['left_knee', 'left_ankle'],
            ['right_hip', 'right_knee'], ['right_knee', 'right_ankle']
        ];
        
        connections.forEach(([point1, point2]) => {
            const landmark1 = landmarks[point1];
            const landmark2 = landmarks[point2];
            
            if (landmark1 && landmark2 && 
                landmark1.visibility > 0.6 && landmark2.visibility > 0.6) {
                
                const x1 = landmark1.x * 640;
                const y1 = landmark1.y * 480;
                const x2 = landmark2.x * 640;
                const y2 = landmark2.y * 480;
                
                // Draw thicker lines with shadow for better visibility
                this.overlayCtx.beginPath();
                this.overlayCtx.moveTo(x1, y1);
                this.overlayCtx.lineTo(x2, y2);
                this.overlayCtx.stroke();
            }
        });
    }
}

// Initialize when page loads
document.addEventListener('DOMContentLoaded', () => {
    console.log('Page loaded, initializing app...');
    window.workoutApp = new SimpleWorkoutApp();
});
</script>
{% endblock %}