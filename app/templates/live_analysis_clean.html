{% extends "base.html" %}

{% block head %}
<style>
#camera-container {
    position: relative;
    display: inline-block;
    max-width: 100%;
    overflow: hidden; /* Ensure overlay doesn't extend beyond container */
}

#video {
    display: block;
    max-width: 100%;
    height: auto;
    border: 2px solid #ddd;
    border-radius: 8px;
}

#overlay-canvas {
    position: absolute;
    pointer-events: none;
    border-radius: 6px;
    z-index: 10;
    /* Canvas will be dynamically positioned and sized */
}

@media (max-width: 768px) {
    #camera-container {
        width: 100%;
    }
    
    #video {
        width: 100%;
        max-width: 100%;
    }
}
</style>
{% endblock %}

{% block content %}
<div class="row">
    <div class="col-12">
        <h2>Live Workout Analysis</h2>
        <p class="text-muted">AI-powered real-time workout tracking with pose detection</p>
    </div>
</div>

<div class="row">
    <div class="col-lg-8">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="mb-0">Camera Feed</h5>
                <div class="d-flex align-items-center gap-2">
                    <span id="fps-counter" class="badge bg-info">0 FPS</span>
                    <span id="connection-status" class="badge bg-secondary">Disconnected</span>
                </div>
            </div>
            <div class="card-body">
                <div id="camera-container" class="text-center">
                    <video id="video" width="640" height="480" autoplay playsinline muted 
                           style="border: 2px solid #ddd; border-radius: 8px; max-width: 100%; height: auto;"></video>
                    <canvas id="canvas" width="640" height="480" style="display: none;"></canvas>
                    <canvas id="overlay-canvas" 
                            style="position: absolute; pointer-events: none; border-radius: 6px;"></canvas>
                </div>
                
                <div class="mt-3 text-center">
                    <div class="btn-group mb-2" role="group">
                        <button id="start-camera" class="btn btn-primary">
                            <i class="fas fa-video"></i> Start Camera
                        </button>
                        <button id="switch-camera" class="btn btn-outline-primary" disabled>
                            <i class="fas fa-camera-rotate"></i> Switch
                        </button>
                        <button id="stop-camera" class="btn btn-danger" disabled>
                            <i class="fas fa-video-slash"></i> Stop
                        </button>
                    </div>
                </div>
                
                <div class="mt-2 text-center">
                    <small id="camera-info" class="text-muted">Click Start Camera to begin</small>
                </div>
            </div>
        </div>
    </div>

    <div class="col-lg-4">
        <div class="card mb-3">
            <div class="card-header">
                <h5 class="mb-0">Exercise Selection</h5>
            </div>
            <div class="card-body">
                <select id="exercise-select" class="form-select mb-3">
                    <option value="">Select Exercise</option>
                    <option value="push_ups">Push-ups</option>
                    <option value="squats">Squats</option>
                    <option value="bicep_curls">Bicep Curls</option>
                </select>
                <button id="start-workout" class="btn btn-success w-100" disabled>
                    <i class="fas fa-play"></i> Start Workout
                </button>
                <button id="end-workout" class="btn btn-warning w-100 mt-2" disabled>
                    <i class="fas fa-stop"></i> End Workout
                </button>
            </div>
        </div>

        <div class="card mb-3">
            <div class="card-header">
                <h5 class="mb-0">Live Stats</h5>
            </div>
            <div class="card-body">
                <div class="row text-center">
                    <div class="col-4">
                        <h2 id="rep-count" class="text-primary mb-0">0</h2>
                        <small class="text-muted">Reps</small>
                    </div>
                    <div class="col-4">
                        <h2 id="accuracy" class="text-success mb-0">0%</h2>
                        <small class="text-muted">Accuracy</small>
                    </div>
                    <div class="col-4">
                        <h2 id="phase" class="text-info mb-0">Ready</h2>
                        <small class="text-muted">Phase</small>
                    </div>
                </div>
                <div class="mt-3 text-center">
                    <div class="row">
                        <div class="col-6">
                            <small class="text-muted">Duration</small>
                            <div id="duration" class="fw-bold">00:00</div>
                        </div>
                        <div class="col-6">
                            <small class="text-muted">Calories</small>
                            <div id="calories" class="fw-bold">0</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="card mb-3">
            <div class="card-header">
                <h5 class="mb-0">Live Feedback</h5>
            </div>
            <div class="card-body">
                <div id="current-feedback" class="alert alert-info mb-2">
                    Select an exercise and start your camera
                </div>
            </div>
        </div>

        <div class="card">
            <div class="card-header">
                <h5 class="mb-0">Settings</h5>
            </div>
            <div class="card-body">
                <div class="form-check form-switch mb-2">
                    <input class="form-check-input" type="checkbox" id="show-skeleton" checked>
                    <label class="form-check-label" for="show-skeleton">
                        Show Skeleton
                    </label>
                </div>
                <div class="form-check form-switch mb-2">
                    <input class="form-check-input" type="checkbox" id="voice-feedback">
                    <label class="form-check-label" for="voice-feedback">
                        Voice Feedback
                    </label>
                </div>
                <div class="form-check form-switch">
                    <input class="form-check-input" type="checkbox" id="mirror-mode" checked>
                    <label class="form-check-label" for="mirror-mode">
                        Mirror Mode
                    </label>
                </div>
                <div class="form-check form-switch">
                    <input class="form-check-input" type="checkbox" id="debug-mode">
                    <label class="form-check-label" for="debug-mode">
                        Debug Alignment
                    </label>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
class WorkoutApp {
    constructor() {
        this.video = document.getElementById('video');
        this.canvas = document.getElementById('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.overlayCanvas = document.getElementById('overlay-canvas');
        this.overlayCtx = this.overlayCanvas.getContext('2d');
        
        this.currentStream = null;
        this.websocket = null;
        this.sessionId = null;
        this.isWorkoutActive = false;
        this.frameInterval = null;
        this.startTime = null;
        this.durationInterval = null;
        
        this.availableCameras = [];
        this.currentCameraIndex = 0;
        this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        this.settings = {
            showSkeleton: true,
            voiceFeedback: false,
            mirrorMode: true,
            debugMode: false
        };
        
        // Voice feedback system
        this.lastSpokenFeedback = '';
        this.speechQueue = [];
        this.isSpeaking = false;
        this.lastSpeechTime = 0;
        this.lastRepCount = 0;
        
        this.init();
    }
    
    init() {
        console.log('Initializing Workout App...');
        this.setupEventListeners();
        this.detectCameras();
        this.setupResizeHandler();
        this.initializeVoices();
        console.log('Workout App initialized');
    }
    
    initializeVoices() {
        // Initialize speech synthesis voices
        if ('speechSynthesis' in window) {
            // Load voices
            speechSynthesis.getVoices();
            
            // Some browsers need this event to load voices
            speechSynthesis.onvoiceschanged = () => {
                const voices = speechSynthesis.getVoices();
                console.log('Available voices:', voices.length);
                if (voices.length > 0) {
                    console.log('Voice feedback ready');
                }
            };
        } else {
            console.warn('Speech synthesis not supported in this browser');
        }
    }
    
    setupResizeHandler() {
        // Handle window resize to keep skeleton aligned
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                this.updateCanvasSize();
            }, 100);
        });
        
        // Also handle video resize events
        this.video.addEventListener('loadedmetadata', () => {
            setTimeout(() => this.updateCanvasSize(), 100);
        });
        
        this.video.addEventListener('loadeddata', () => {
            setTimeout(() => this.updateCanvasSize(), 200);
        });
        
        this.video.addEventListener('canplay', () => {
            setTimeout(() => this.updateCanvasSize(), 300);
        });
        
        // Handle video element resize
        if (window.ResizeObserver) {
            const videoResizeObserver = new ResizeObserver(() => {
                this.updateCanvasSize();
            });
            videoResizeObserver.observe(this.video);
        }
    }
    
    updateCanvasSize() {
        if (!this.video || !this.overlayCanvas) return;
        
        // Wait for video to be fully loaded
        if (this.video.videoWidth === 0 || this.video.videoHeight === 0) {
            setTimeout(() => this.updateCanvasSize(), 100);
            return;
        }
        
        const videoRect = this.video.getBoundingClientRect();
        const containerRect = document.getElementById('camera-container').getBoundingClientRect();
        
        // CRITICAL: Calculate the exact camera frame boundaries
        // The video element may have black borders, but we need to align with the actual camera content
        
        const videoNativeWidth = this.video.videoWidth;
        const videoNativeHeight = this.video.videoHeight;
        const videoNativeAspectRatio = videoNativeWidth / videoNativeHeight;
        
        const videoDisplayWidth = videoRect.width;
        const videoDisplayHeight = videoRect.height;
        const videoDisplayAspectRatio = videoDisplayWidth / videoDisplayHeight;
        
        // Calculate the actual camera frame dimensions within the video element
        let actualFrameWidth, actualFrameHeight, frameOffsetX = 0, frameOffsetY = 0;
        
        if (videoNativeAspectRatio > videoDisplayAspectRatio) {
            // Camera frame is wider - black bars on top and bottom
            actualFrameWidth = videoDisplayWidth;
            actualFrameHeight = videoDisplayWidth / videoNativeAspectRatio;
            frameOffsetY = (videoDisplayHeight - actualFrameHeight) / 2;
        } else {
            // Camera frame is taller - black bars on left and right
            actualFrameHeight = videoDisplayHeight;
            actualFrameWidth = videoDisplayHeight * videoNativeAspectRatio;
            frameOffsetX = (videoDisplayWidth - actualFrameWidth) / 2;
        }
        
        // Position canvas to match EXACTLY the camera frame boundaries
        const canvasLeft = videoRect.left - containerRect.left + frameOffsetX;
        const canvasTop = videoRect.top - containerRect.top + frameOffsetY;
        
        this.overlayCanvas.style.position = 'absolute';
        this.overlayCanvas.style.left = canvasLeft + 'px';
        this.overlayCanvas.style.top = canvasTop + 'px';
        this.overlayCanvas.style.width = actualFrameWidth + 'px';
        this.overlayCanvas.style.height = actualFrameHeight + 'px';
        
        // Set canvas internal dimensions to match the actual camera frame
        this.overlayCanvas.width = actualFrameWidth;
        this.overlayCanvas.height = actualFrameHeight;
        
        // Store dimensions for skeleton drawing
        this.canvasWidth = actualFrameWidth;
        this.canvasHeight = actualFrameHeight;
        
        console.log('Camera Frame Alignment:', {
            videoElement: { width: videoDisplayWidth, height: videoDisplayHeight },
            cameraFrame: { width: actualFrameWidth, height: actualFrameHeight },
            frameOffset: { x: frameOffsetX, y: frameOffsetY },
            canvasPosition: { left: canvasLeft, top: canvasTop },
            aspectRatios: { 
                native: videoNativeAspectRatio.toFixed(3), 
                display: videoDisplayAspectRatio.toFixed(3) 
            }
        });
    }
    
    setupEventListeners() {
        document.getElementById('start-camera').addEventListener('click', () => this.startCamera());
        document.getElementById('switch-camera').addEventListener('click', () => this.switchCamera());
        document.getElementById('stop-camera').addEventListener('click', () => this.stopCamera());
        
        document.getElementById('start-workout').addEventListener('click', () => this.startWorkout());
        document.getElementById('end-workout').addEventListener('click', () => this.endWorkout());
        
        document.getElementById('exercise-select').addEventListener('change', () => this.updateStartButton());
        
        document.getElementById('show-skeleton').addEventListener('change', (e) => {
            this.settings.showSkeleton = e.target.checked;
            if (!this.settings.showSkeleton) {
                this.clearOverlay();
            }
        });
        
        document.getElementById('voice-feedback').addEventListener('change', (e) => {
            this.settings.voiceFeedback = e.target.checked;
            if (!this.settings.voiceFeedback && 'speechSynthesis' in window) {
                speechSynthesis.cancel();
            }
        });
        
        document.getElementById('mirror-mode').addEventListener('change', (e) => {
            this.settings.mirrorMode = e.target.checked;
            this.updateVideoMirror();
        });
        
        document.getElementById('debug-mode').addEventListener('change', (e) => {
            this.settings.debugMode = e.target.checked;
            if (this.settings.debugMode) {
                this.overlayCanvas.style.border = '2px solid red';
                this.overlayCanvas.style.backgroundColor = 'rgba(255, 0, 0, 0.1)';
                // Draw test pattern to verify alignment
                this.drawTestPattern();
            } else {
                this.overlayCanvas.style.border = 'none';
                this.overlayCanvas.style.backgroundColor = 'transparent';
                this.clearOverlay();
            }
        });
    }
    
    async detectCameras() {
        try {
            if (this.isMobile) {
                this.availableCameras = [
                    { deviceId: 'front', label: 'Front Camera', facingMode: 'user' },
                    { deviceId: 'back', label: 'Back Camera', facingMode: 'environment' }
                ];
            } else {
                if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const videoDevices = devices.filter(device => device.kind === 'videoinput');
                    
                    if (videoDevices.length > 0) {
                        this.availableCameras = videoDevices.map((device, index) => ({
                            deviceId: device.deviceId,
                            label: device.label || `Camera ${index + 1}`
                        }));
                    } else {
                        this.availableCameras = [{ deviceId: 'default', label: 'Default Camera' }];
                    }
                } else {
                    this.availableCameras = [{ deviceId: 'default', label: 'Default Camera' }];
                }
            }
            
            this.updateCameraInfo();
        } catch (error) {
            console.error('Camera detection error:', error);
            this.availableCameras = [{ deviceId: 'default', label: 'Default Camera' }];
            this.updateCameraInfo();
        }
    }
    
    updateCameraInfo() {
        const cameraInfo = document.getElementById('camera-info');
        if (this.availableCameras.length === 0) {
            cameraInfo.textContent = 'No cameras available';
            return;
        }
        
        const current = this.availableCameras[this.currentCameraIndex];
        const total = this.availableCameras.length;
        cameraInfo.textContent = `${current.label} (${this.currentCameraIndex + 1}/${total})`;
        
        const switchBtn = document.getElementById('switch-camera');
        switchBtn.disabled = total <= 1 || !this.currentStream;
    }
    
    async startCamera() {
        try {
            console.log('Starting camera...');
            this.updateFeedback('Starting camera...', 'info');
            
            let constraints;
            
            if (this.isMobile) {
                const current = this.availableCameras[this.currentCameraIndex];
                constraints = {
                    video: {
                        facingMode: current.facingMode || 'user',
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }
                };
            } else {
                const current = this.availableCameras[this.currentCameraIndex];
                constraints = {
                    video: {
                        deviceId: current.deviceId !== 'default' ? { exact: current.deviceId } : undefined,
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }
                };
            }
            
            console.log('Camera constraints:', constraints);
            
            this.currentStream = await navigator.mediaDevices.getUserMedia(constraints);
            this.video.srcObject = this.currentStream;
            
            await new Promise((resolve, reject) => {
                const timeout = setTimeout(() => reject(new Error('Video timeout')), 10000);
                
                this.video.onloadedmetadata = () => {
                    clearTimeout(timeout);
                    this.video.play().then(() => {
                        // Update canvas size after video is loaded and playing
                        setTimeout(() => {
                            this.updateCanvasSize();
                            resolve();
                        }, 200);
                    }).catch(reject);
                };
            });
            
            document.getElementById('start-camera').disabled = true;
            document.getElementById('stop-camera').disabled = false;
            this.updateCameraInfo();
            this.updateStartButton();
            this.updateVideoMirror();
            
            this.updateFeedback('Camera started successfully!', 'success');
            console.log('Camera started successfully');
            
        } catch (error) {
            console.error('Camera error:', error);
            
            let message = 'Camera failed: ';
            if (error.name === 'NotAllowedError') {
                message += 'Permission denied. Please allow camera access.';
            } else if (error.name === 'NotFoundError') {
                message += 'No camera found.';
            } else if (error.name === 'NotReadableError') {
                message += 'Camera in use by another app.';
            } else {
                message += error.message;
            }
            
            this.updateFeedback(message, 'danger');
        }
    }
    
    async switchCamera() {
        if (this.availableCameras.length <= 1) {
            this.updateFeedback('Only one camera available', 'info');
            return;
        }
        
        try {
            if (this.currentStream) {
                this.currentStream.getTracks().forEach(track => track.stop());
            }
            
            this.currentCameraIndex = (this.currentCameraIndex + 1) % this.availableCameras.length;
            await this.startCamera();
            
        } catch (error) {
            console.error('Camera switch error:', error);
            this.updateFeedback('Failed to switch camera', 'danger');
        }
    }
    
    stopCamera() {
        if (this.currentStream) {
            this.currentStream.getTracks().forEach(track => track.stop());
            this.video.srcObject = null;
            this.currentStream = null;
        }
        
        document.getElementById('start-camera').disabled = false;
        document.getElementById('stop-camera').disabled = true;
        this.updateCameraInfo();
        this.updateStartButton();
        this.clearOverlay();
        
        this.updateFeedback('Camera stopped', 'info');
    }
    
    updateVideoMirror() {
        if (this.settings.mirrorMode && this.isMobile && 
            this.availableCameras[this.currentCameraIndex]?.facingMode === 'user') {
            this.video.style.transform = 'scaleX(-1)';
            this.overlayCanvas.style.transform = 'scaleX(-1)';
        } else {
            this.video.style.transform = '';
            this.overlayCanvas.style.transform = '';
        }
    }
    
    updateStartButton() {
        const startBtn = document.getElementById('start-workout');
        const exercise = document.getElementById('exercise-select').value;
        const hasCamera = !!this.currentStream;
        
        startBtn.disabled = !exercise || !hasCamera || this.isWorkoutActive;
        
        if (!exercise) {
            startBtn.innerHTML = '<i class="fas fa-play"></i> Select Exercise First';
        } else if (!hasCamera) {
            startBtn.innerHTML = '<i class="fas fa-play"></i> Start Camera First';
        } else if (this.isWorkoutActive) {
            startBtn.innerHTML = '<i class="fas fa-play"></i> Workout Active';
        } else {
            startBtn.innerHTML = '<i class="fas fa-play"></i> Start Workout';
        }
    }
    
    async startWorkout() {
        const exercise = document.getElementById('exercise-select').value;
        
        if (!exercise || !this.currentStream) {
            this.updateFeedback('Please select exercise and start camera', 'warning');
            return;
        }
        
        try {
            console.log('Starting workout:', exercise);
            this.updateFeedback('Starting workout...', 'info');
            
            const response = await fetch('/live/start-session', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    exercise_name: exercise,
                    user_id: 'demo_user'
                })
            });
            
            if (!response.ok) {
                throw new Error(`Server error: ${response.status}`);
            }
            
            const data = await response.json();
            this.sessionId = data.session_id;
            
            await this.connectWebSocket();
            
            this.isWorkoutActive = true;
            this.startTime = Date.now();
            this.lastRepCount = 0; // Reset rep counter
            this.startFrameCapture();
            this.startDurationTimer();
            
            document.getElementById('start-workout').disabled = true;
            document.getElementById('end-workout').disabled = false;
            document.getElementById('exercise-select').disabled = true;
            
            this.updateFeedback(`Workout started! Exercise: ${exercise.replace('_', ' ')}`, 'success');
            
            // Voice feedback for workout start
            this.speakFeedback(`Starting ${exercise.replace('_', ' ')} workout. Get ready!`, 'high');
            
        } catch (error) {
            console.error('Workout start error:', error);
            this.updateFeedback('Failed to start workout: ' + error.message, 'danger');
        }
    }
    
    async connectWebSocket() {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.host}/live/ws/${this.sessionId}`;
        
        return new Promise((resolve, reject) => {
            this.websocket = new WebSocket(wsUrl);
            
            this.websocket.onopen = () => {
                console.log('WebSocket connected');
                document.getElementById('connection-status').textContent = 'Connected';
                document.getElementById('connection-status').className = 'badge bg-success';
                resolve();
            };
            
            this.websocket.onmessage = (event) => {
                const message = JSON.parse(event.data);
                this.handleWebSocketMessage(message);
            };
            
            this.websocket.onclose = () => {
                console.log('WebSocket closed');
                document.getElementById('connection-status').textContent = 'Disconnected';
                document.getElementById('connection-status').className = 'badge bg-danger';
            };
            
            this.websocket.onerror = (error) => {
                console.error('WebSocket error:', error);
                reject(error);
            };
            
            setTimeout(() => {
                if (this.websocket.readyState !== WebSocket.OPEN) {
                    reject(new Error('WebSocket timeout'));
                }
            }, 10000);
        });
    }
    
    handleWebSocketMessage(message) {
        switch (message.type) {
            case 'connected':
                this.updateFeedback(message.data.message, 'success');
                break;
                
            case 'analysis_result':
                this.updateStats(message.data);
                
                // Process voice feedback for form analysis
                if (message.data.form_feedback && message.data.form_feedback.length > 0) {
                    this.processVoiceFeedback(message.data.form_feedback, 'analysis');
                }
                
                if (this.settings.showSkeleton && message.data.landmarks) {
                    // Ensure canvas is properly sized before drawing
                    this.updateCanvasSize();
                    this.drawSkeleton(message.data.landmarks);
                } else if (!this.settings.showSkeleton) {
                    this.clearOverlay();
                }
                break;
                
            case 'feedback':
                if (message.data.feedback && message.data.feedback.length > 0) {
                    this.updateFeedback(message.data.feedback[message.data.feedback.length - 1], 'warning');
                    // Add voice feedback for explicit feedback messages
                    this.processVoiceFeedback(message.data.feedback, 'feedback');
                }
                break;
                
            case 'rep_update':
                this.updateRepCount(message.data.rep_count, message.data.current_phase);
                // Announce rep completion
                if (message.data.rep_count > this.lastRepCount) {
                    this.speakFeedback(`Rep ${message.data.rep_count} completed`, 'high');
                    this.lastRepCount = message.data.rep_count;
                }
                break;
                
            case 'session_complete':
                this.handleSessionComplete(message.data);
                break;
                
            case 'error':
                this.updateFeedback('Error: ' + message.data.message, 'danger');
                break;
        }
    }
    
    startFrameCapture() {
        this.frameInterval = setInterval(() => {
            if (this.isWorkoutActive && this.websocket && 
                this.websocket.readyState === WebSocket.OPEN) {
                this.captureAndSendFrame();
            }
        }, 100); // 10 FPS
    }
    
    captureAndSendFrame() {
        try {
            // Get the actual video dimensions for proper scaling
            const videoWidth = this.video.videoWidth || 640;
            const videoHeight = this.video.videoHeight || 480;
            
            // Set canvas to match video's actual resolution
            this.canvas.width = videoWidth;
            this.canvas.height = videoHeight;
            
            this.ctx.clearRect(0, 0, videoWidth, videoHeight);
            this.ctx.drawImage(this.video, 0, 0, videoWidth, videoHeight);
            
            const imageData = this.canvas.toDataURL('image/jpeg', 0.7);
            
            this.websocket.send(JSON.stringify({
                type: 'frame',
                data: {
                    image: imageData,
                    timestamp: Date.now(),
                    videoWidth: videoWidth,
                    videoHeight: videoHeight
                }
            }));
            
        } catch (error) {
            console.error('Frame capture error:', error);
        }
    }
    
    updateStats(data) {
        document.getElementById('rep-count').textContent = data.rep_count || 0;
        document.getElementById('accuracy').textContent = Math.round((data.accuracy_score || 0) * 100) + '%';
        document.getElementById('phase').textContent = data.current_phase || 'Ready';
        
        const accuracyElement = document.getElementById('accuracy');
        const accuracy = data.accuracy_score || 0;
        
        if (accuracy >= 0.8) {
            accuracyElement.className = 'text-success mb-0';
        } else if (accuracy >= 0.6) {
            accuracyElement.className = 'text-warning mb-0';
        } else {
            accuracyElement.className = 'text-danger mb-0';
        }
        
        const duration = this.startTime ? (Date.now() - this.startTime) / 1000 / 60 : 0;
        const calories = Math.round(duration * 5);
        document.getElementById('calories').textContent = calories;
    }
    
    updateRepCount(repCount, phase) {
        document.getElementById('rep-count').textContent = repCount;
        document.getElementById('phase').textContent = phase;
    }
    
    drawSkeleton(landmarks) {
        if (!this.settings.showSkeleton || !landmarks || !this.video || !this.overlayCanvas) return;
        
        // Skip if video is not loaded
        if (this.video.videoWidth === 0 || this.video.videoHeight === 0) return;
        
        // Ensure canvas is properly sized
        this.updateCanvasSize();
        
        // Clear the canvas
        this.overlayCtx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);
        
        // Use stored canvas dimensions
        const canvasWidth = this.canvasWidth || this.overlayCanvas.width;
        const canvasHeight = this.canvasHeight || this.overlayCanvas.height;
        
        // SIMPLE COORDINATE MAPPING: MediaPipe gives normalized coordinates (0-1)
        // Just multiply by canvas dimensions - no complex transformations
        
        // Drawing styles
        const lineWidth = Math.max(3, Math.min(6, canvasWidth / 150));
        const pointRadius = Math.max(5, Math.min(10, canvasWidth / 100));
        
        // Skeleton connections
        const connections = [
            ['left_shoulder', 'right_shoulder'],
            ['left_shoulder', 'left_elbow'],
            ['left_elbow', 'left_wrist'],
            ['right_shoulder', 'right_elbow'],
            ['right_elbow', 'right_wrist'],
            ['left_shoulder', 'left_hip'],
            ['right_shoulder', 'right_hip'],
            ['left_hip', 'right_hip'],
            ['left_hip', 'left_knee'],
            ['left_knee', 'left_ankle'],
            ['right_hip', 'right_knee'],
            ['right_knee', 'right_ankle']
        ];
        
        // Set line style
        this.overlayCtx.strokeStyle = '#00ff00';
        this.overlayCtx.lineWidth = lineWidth;
        this.overlayCtx.lineCap = 'round';
        this.overlayCtx.lineJoin = 'round';
        
        // Draw skeleton lines
        connections.forEach(([start, end]) => {
            if (landmarks[start] && landmarks[end] && 
                landmarks[start].visibility > 0.5 && landmarks[end].visibility > 0.5) {
                
                // Simple coordinate conversion: normalized (0-1) to canvas pixels
                const startX = landmarks[start].x * canvasWidth;
                const startY = landmarks[start].y * canvasHeight;
                const endX = landmarks[end].x * canvasWidth;
                const endY = landmarks[end].y * canvasHeight;
                
                this.overlayCtx.beginPath();
                this.overlayCtx.moveTo(startX, startY);
                this.overlayCtx.lineTo(endX, endY);
                this.overlayCtx.stroke();
            }
        });
        
        // Draw landmark points
        Object.entries(landmarks).forEach(([name, landmark]) => {
            if (landmark.visibility > 0.5) {
                // Simple coordinate conversion
                const x = landmark.x * canvasWidth;
                const y = landmark.y * canvasHeight;
                
                // Color coding for different body parts
                if (name.includes('shoulder') || name.includes('elbow') || name.includes('wrist')) {
                    this.overlayCtx.fillStyle = '#0066ff'; // Blue for arms
                } else if (name.includes('hip') || name.includes('knee') || name.includes('ankle')) {
                    this.overlayCtx.fillStyle = '#ff6600'; // Orange for legs
                } else {
                    this.overlayCtx.fillStyle = '#ffff00'; // Yellow for head/torso
                }
                
                // Draw point with white border
                this.overlayCtx.beginPath();
                this.overlayCtx.arc(x, y, pointRadius, 0, 2 * Math.PI);
                this.overlayCtx.fill();
                
                this.overlayCtx.strokeStyle = '#ffffff';
                this.overlayCtx.lineWidth = 2;
                this.overlayCtx.beginPath();
                this.overlayCtx.arc(x, y, pointRadius, 0, 2 * Math.PI);
                this.overlayCtx.stroke();
            }
        });
        
        // Debug info
        if (this.settings.debugMode) {
            const videoRect = this.video.getBoundingClientRect();
            console.log('Skeleton Drawing Debug:', {
                canvasSize: { width: canvasWidth, height: canvasHeight },
                videoNative: { width: this.video.videoWidth, height: this.video.videoHeight },
                videoDisplay: { width: videoRect.width, height: videoRect.height },
                canvasPosition: { 
                    left: this.overlayCanvas.style.left, 
                    top: this.overlayCanvas.style.top 
                },
                sampleLandmark: landmarks.nose ? {
                    normalized: { x: landmarks.nose.x.toFixed(3), y: landmarks.nose.y.toFixed(3) },
                    canvasPixel: { 
                        x: Math.round(landmarks.nose.x * canvasWidth), 
                        y: Math.round(landmarks.nose.y * canvasHeight) 
                    }
                } : null
            });
        }
    }
    
    clearOverlay() {
        if (this.overlayCanvas) {
            this.overlayCtx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);
        }
    }
    
    // Voice Feedback System
    speakFeedback(message, priority = 'normal') {
        if (!this.settings.voiceFeedback || !('speechSynthesis' in window)) {
            return;
        }
        
        // Avoid repeating the same message too frequently
        if (message === this.lastSpokenFeedback && Date.now() - this.lastSpeechTime < 3000) {
            return;
        }
        
        // Cancel current speech for high priority messages
        if (priority === 'high' && this.isSpeaking) {
            speechSynthesis.cancel();
            this.speechQueue = [];
        }
        
        // Add to queue if currently speaking
        if (this.isSpeaking && priority !== 'high') {
            this.speechQueue.push(message);
            return;
        }
        
        this.speakMessage(message);
    }
    
    speakMessage(message) {
        if (!('speechSynthesis' in window)) {
            console.warn('Speech synthesis not supported');
            return;
        }
        
        const utterance = new SpeechSynthesisUtterance(message);
        
        // Configure voice settings
        utterance.rate = 1.0;
        utterance.pitch = 1.0;
        utterance.volume = 0.8;
        
        // Try to use a clear, natural voice
        const voices = speechSynthesis.getVoices();
        const preferredVoice = voices.find(voice => 
            voice.lang.startsWith('en') && 
            (voice.name.includes('Google') || voice.name.includes('Microsoft') || voice.default)
        );
        if (preferredVoice) {
            utterance.voice = preferredVoice;
        }
        
        utterance.onstart = () => {
            this.isSpeaking = true;
            this.lastSpokenFeedback = message;
            this.lastSpeechTime = Date.now();
        };
        
        utterance.onend = () => {
            this.isSpeaking = false;
            // Process next message in queue
            if (this.speechQueue.length > 0) {
                const nextMessage = this.speechQueue.shift();
                setTimeout(() => this.speakMessage(nextMessage), 500);
            }
        };
        
        utterance.onerror = (event) => {
            console.error('Speech synthesis error:', event);
            this.isSpeaking = false;
        };
        
        speechSynthesis.speak(utterance);
    }
    
    // Enhanced feedback processing for different types of messages
    processVoiceFeedback(feedback, type = 'info') {
        if (!this.settings.voiceFeedback) return;
        
        let message = '';
        let priority = 'normal';
        
        // Process different types of feedback
        if (Array.isArray(feedback)) {
            // Multiple feedback items - pick the most important
            const importantFeedback = feedback.find(f => 
                f.includes('Excellent') || f.includes('Perfect') || f.includes('Good')
            ) || feedback[feedback.length - 1];
            message = importantFeedback;
        } else {
            message = feedback;
        }
        
        // Set priority based on message content
        if (message.includes('Excellent') || message.includes('Perfect')) {
            priority = 'high';
        } else if (message.includes('rep completed') || message.includes('Good')) {
            priority = 'normal';
        }
        
        // Clean up message for speech
        message = this.cleanMessageForSpeech(message);
        
        if (message) {
            this.speakFeedback(message, priority);
        }
    }
    
    cleanMessageForSpeech(message) {
        // Remove or replace text that doesn't sound good when spoken
        return message
            .replace(/!/g, '') // Remove exclamation marks
            .replace(/\s+/g, ' ') // Normalize whitespace
            .trim();
    }
    
    drawTestPattern() {
        if (!this.overlayCanvas) return;
        
        this.updateCanvasSize();
        this.overlayCtx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);
        
        const width = this.overlayCanvas.width;
        const height = this.overlayCanvas.height;
        
        // Draw frame boundary outline
        this.overlayCtx.strokeStyle = '#ff0000';
        this.overlayCtx.lineWidth = 3;
        this.overlayCtx.strokeRect(0, 0, width, height);
        
        // Draw crosshairs to show center
        this.overlayCtx.strokeStyle = '#00ff00';
        this.overlayCtx.lineWidth = 2;
        
        // Vertical center line
        this.overlayCtx.beginPath();
        this.overlayCtx.moveTo(width / 2, 0);
        this.overlayCtx.lineTo(width / 2, height);
        this.overlayCtx.stroke();
        
        // Horizontal center line
        this.overlayCtx.beginPath();
        this.overlayCtx.moveTo(0, height / 2);
        this.overlayCtx.lineTo(width, height / 2);
        this.overlayCtx.stroke();
        
        // Corner markers to show exact frame boundaries
        this.overlayCtx.fillStyle = '#ffff00';
        const markerSize = 15;
        
        // Top-left corner
        this.overlayCtx.fillRect(0, 0, markerSize, markerSize);
        // Top-right corner
        this.overlayCtx.fillRect(width - markerSize, 0, markerSize, markerSize);
        // Bottom-left corner
        this.overlayCtx.fillRect(0, height - markerSize, markerSize, markerSize);
        // Bottom-right corner
        this.overlayCtx.fillRect(width - markerSize, height - markerSize, markerSize, markerSize);
        
        // Add text to show this is the camera frame boundary
        this.overlayCtx.fillStyle = '#ffffff';
        this.overlayCtx.font = '16px Arial';
        this.overlayCtx.fillText('CAMERA FRAME', 10, 30);
        this.overlayCtx.fillText(`${width}x${height}`, 10, 50);
        
        console.log('Camera frame test pattern:', { width, height });
    }
    
    startDurationTimer() {
        this.durationInterval = setInterval(() => {
            if (this.startTime) {
                const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                document.getElementById('duration').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }, 1000);
    }
    
    async endWorkout() {
        this.isWorkoutActive = false;
        
        if (this.frameInterval) {
            clearInterval(this.frameInterval);
            this.frameInterval = null;
        }
        
        if (this.durationInterval) {
            clearInterval(this.durationInterval);
            this.durationInterval = null;
        }
        
        if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
            this.websocket.send(JSON.stringify({ 
                type: 'end_session', 
                data: {} 
            }));
        }
        
        document.getElementById('start-workout').disabled = false;
        document.getElementById('end-workout').disabled = true;
        document.getElementById('exercise-select').disabled = false;
        
        this.updateStartButton();
        this.clearOverlay();
        this.updateFeedback('Workout ended!', 'info');
        
        // Voice feedback for workout end
        const finalReps = this.lastRepCount;
        if (finalReps > 0) {
            this.speakFeedback(`Workout complete! You did ${finalReps} reps. Great job!`, 'high');
        } else {
            this.speakFeedback('Workout ended. Great effort!', 'high');
        }
    }
    
    handleSessionComplete(data) {
        console.log('Session complete:', data);
        this.updateFeedback('Workout session complete!', 'success');
        
        // Voice feedback for session completion with stats
        if (data.total_reps && data.average_accuracy) {
            const accuracy = Math.round(data.average_accuracy * 100);
            this.speakFeedback(`Session complete! ${data.total_reps} reps with ${accuracy}% accuracy. Well done!`, 'high');
        } else {
            this.speakFeedback('Session complete! Well done!', 'high');
        }
        
        if (this.websocket) {
            this.websocket.close();
            this.websocket = null;
        }
    }
    
    updateFeedback(message, type = 'info') {
        const feedbackDiv = document.getElementById('current-feedback');
        feedbackDiv.textContent = message;
        feedbackDiv.className = `alert alert-${type} mb-2`;
        console.log(`Feedback (${type}): ${message}`);
    }
}

// Initialize when page loads
document.addEventListener('DOMContentLoaded', function() {
    console.log('Initializing Workout App...');
    window.workoutApp = new WorkoutApp();
});
</script>
{% endblock %}